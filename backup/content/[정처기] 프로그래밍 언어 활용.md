---
title: "[정처기] 프로그래밍 언어 활용"
description: "사용자로부터 입력받은 데이터의 자료형태를 저장C 언에어서는 scanf(서식 문자열, 변수의 주소)scanf("%3d", &a);	\- % : 서식 문자임을 지정    \- 3 : 입력 자릿수를 3자리로 지정    \- d : 10진수로 입력    \- &a : 입력받은"
date: 2021-06-19T11:01:10.475Z
tags: []
---
### 서식 문자열
- 사용자로부터 입력받은 데이터의 자료형태를 저장
- C 언에어서는 scanf(서식 문자열, 변수의 주소)
scanf("%3d", &a);
	- % : 서식 문자임을 지정
    - 3 : 입력 자릿수를 3자리로 지정
    - d : 10진수로 입력
    - &a : 입력받은 데이터를 변수 a의 주소에 저장. 
    - 공백과 . 도 자릿수를 갖는다.
- C 언어에서 printf(서식 문자열, 변수) 함수로도 동일하게 작동한다. 
- d : decimal , c : character , s : string , f : float, e : exponent
- p : pointer , l : long , o : 8진수 , x : 16진수, u : unsigned
- 예) 
```c
/* -----------1----------- */
char a[5];
scanf("%d %e %s", &i, &j, a);
// 입력 : 5468 3.483E-2 GOOD
printf("%4d %f %2s", i, j, a);
// 출력 : 5468 0.034830 GOOD

/* -----------2----------- */
scanf("%e", &i);
// 입력 : 123.45E-1
printf("%f\t %e\n", i, i);
// 출력 : 12.345000	1.234500e+01

/* -----------3----------- */
scanf("%d", &i);
// 입력 : 300
printf("[%5d], [%-5d], [%05d]", i, i, i);
// 출력 : [  300]. [300  ]. [00300]

```

### Scanner 클래스 
- 자바에서 사용자 입력에 사용하는 객체 변수를 만들 때 사용하는 클래스 이름. 
Scanner scan01 = new Scanner(System.in);
inNum = scan01.nextInt();
	- Scanner : 클래스 이름
    - scan01 : 객체 변수명
    - new : 객체 생성 예약어
    - Scanner() : 클래스 이름
    - System.int : 표준 입력장치 / 키도브로부터 값을 입력 받는 값
    - inNum : 입력받은 값을 저장할 변수
    - scan01 : 입력에 사용할 객체 변수 이름
    - nextInt() : 입력 받은 값을 정수형으로 반환. 

### 절차적 프로그래밍 언어의 종류
| 언어 | 특징  |
|----|-----|
| C | - 1971 미국 벨 연구소 데이스 리치가 개발 <br> - 소프트웨어 개발 언어 <br> - 컴파일러 방식이며 컴퓨터 기종에 관계없이 프로그래밍 작성이 가능함. |
| ALGOL | - 수치 계산, 논리 연산을 위한 과학 기술 계산용 언어 <br> - PASCAL과 C 언어의 parent |
| COBOL | - 사무 처리용 언어 <br> - 영어 문장 형식임 <br> - 4개의 DIVISION으로 구성됨 |
| FORTRAN | - 과학 기술 계산용 언어 <br> - 수학과 공학 분야의 공식, 수식과 같은 형태로 프로그래밍 가능. |

### 객체지향 프로그래밍 언어의 특징
| 특징 | 설명  |
|----|-----|
| 캡술화 | - 데이터의 속성과 데이터 액션(함수)를 하나로 묶고 객체화하여 객체의 세부 내용이 외부에 은폐됨. <br> - 캡슐화된 객체는 재사용이 용이함. |
| 정보 은닉 | - 다른 객체에게 자신의 정보를 숨기고 허용된 연산만이 가능하게 함|
| 추상화 | - 불필요한 정보를 생략하고 가장 중요한 속성만 모델화하는 것 <br> - 데이터의 공통된 요소만 추출해서 슈퍼 클래스로 선정해서 구현 |
| 상속성 | - 정의된 부모 클래스의 모든 속성과 액션을 하위 클래스가 물려받음 <br> - 같은 방법 또는 오버라이딩한 방법으로 다시 정의할 필요 없이 재사용 가능. |
| 다형성 | -  객체의 속성과 메소드 등이 다양한 자료형에 속하는 것을 허용함. <br> - 기능 확장과 객체를 변경할 때 타입 변경 없이 객체 주입만으로 수정할 수 있어 유용함. |

**객체지향언어의 장점**
- 상속을 통해 코드 재사용이 가능
- 잘 설계된 클래스를 만들면 개발의 생산성이 향상됨
- 객체의 구조가 일상생활의 모습을 모방하기 때문에 자연스럽게 구현 가능
- 프로그램 수정, 추가해도 캡슐화 때문에 주변에 영향이 적어 경제적임.

**객체지향언어의 단점**
- 객체와 객체가 처리하려는 것에 대한 정확한 이해가 필요해 설계단계에서 오랜 시간이 소모됨
- 상대적으로 실행속도는 더 느림
- 다중 상속이 지원되는 C++의 경우 너무 복잡해서 코드 난이도가 상승함.

**객체 지향 설계의 SOLID 원칙**
- Single Responsiblity Principle (단일 책임 원칙)
	- 소프트웨어의 설계 부품(클래스, 함수 등)은 단 하나의 책임/기능만을 가져야 한다.

- Open-Closed Principle (개방-패쇄 원칙)
	- 기존의 코드를 변경하지 않고(Closed) 기능을 수정하거나 추가할 수 있도록(Open) 설계해야 한다.
    - 인터페이스를 사용하면 확장성을 키울 수 있다.
    ![](/images/9c6b54fd-4cba-43f1-abe8-685d318da0eb-image.png)
    
- Liskov Substitution Principle (리스코프 치환 원칙)
	- 자식 클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다.
    - 부모와 자식 클래스간에 일관성 있는 속성을 상속 받아서 자식 인스턴스를 부모 대신 써도 문제되지 않아야 한다. 

- Interface Segregation Principle (인터페이스 분리 원칙)
	- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.
    - 즉 자신이 쓰지 않는 기능/인터페이스는 영향을 받지 말아야 한다.

- Dependency Inversion Principle (의존 역전 원칙)
	- 의존 관계를 맺을 때, 변화하기 쉬운 것(구체화된 클래스) 보단 변화하기 어려운 것(추상클래스나 인터페이스)에 의존해야 한다는 원칙이다.
    - 즉 의존 관계를 맺을 때 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺어야 한다. 
    ![](/images/62bbd726-4b12-44e7-9a0a-61f5d5a38585-image.png)





### 출처
https://radait.tistory.com/4
https://woowacourse.github.io/javable/post/2020-10-27-polymorphism/
https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99