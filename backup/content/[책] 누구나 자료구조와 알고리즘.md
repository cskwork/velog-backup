---
title: "[책] 누구나 자료구조와 알고리즘"
description: "프로그래밍은 데이터를 다루는 것데이터 : 모든 유형의 정보를 망라하고 기초적인 수와 문자열로 이뤄져 있다.데이터 조직은 코드의 실행 속도에 영향을 미친다.배열 기준 자료 구조 제어의 네 가지 기본 방법. (연산)읽기 : 활당된 메모리 (엑)셀의 특정 위치 찾기검색 : "
date: 2021-05-19T01:54:02.474Z
tags: ["알고리즘"]
---
## 자료구조가 중요한 이유
- 프로그래밍은 데이터를 다루는 것
- 데이터 : 모든 유형의 정보를 망라하고 기초적인 수와 문자열로 이뤄져 있다.
- 데이터 조직/구조은 코드의 실행 속도에 영향을 미친다.
- 배열 기준 자료 구조를 제어하는 네 가지 방법. 
  - 읽기 : 활당된 메모리 (엑)셀의 특정 위치 찾기
  - 검색 : 특정 값을 찾기. N개의 셀로 이뤄진 배열은 선형 검색에서 최대 N개의 단계가 필요하다.
  - 삽입 : 새로운 값 추가. 최악의 시나리오에서 삽입은 N+1 단계 걸림. 셀 맨 앞에 넣으면 요소를 전부 이동시켜 공간을 만드는 N단계가 걸리고 삽입까지 단계까지 포함해서 +1단계가 필요하다.
  - 삭제 : 값 제거

### 🎚 선형 검색 : 
컴퓨터가 한 번에 한 셀씩 확인하는 방법.

 - 집합 : 중복 값이 허용되지 않는 자료 구조.
 - 집합에서 삽입 : 찾고자 하는 값이 있는지 우선 검색을 통해서 확인한 후 N단계 삽입을 진행시 필요한 N+1 단계가 필요하므로 총 2N+1 단계가 걸림. 

## 알고리즘이 중요한 이유
- 알고리즘: 연산 (문제 해결)을 풀어나가는 구체적인 절차

### 👀 이진 검색 : 
정렬된 셀의 중간 지점을 연산하고 찾으려는 값의 크기에 따라서 새로운 상한선 또는 하한선을 구하고 새로운 중간 값을 연산한 후 조건에 따라서 상한선/하한선을 바꾸는 패스스루를 하면서 찾고 있는 값이 나올 때까지 또는 모든 값의 검색이 끝날때 까지 반복한다.

```c
int BinarySearch(int arr[], int size, int target)
{
    int first = 0;
    int last = n - 1;
    int mid;
 
    while(first <= last)
    {
        mid = (first + last) / 2;
        if(target == arr[mid])
            return mid;
        else if(target < arr[mid])
            last = mid-1;
        else 
            first = mid + 1;
    }
    
    return -1;
}

```
### Big O 표기법 성능 차이
![](/images/d2b2ac8d-2442-4488-98e6-5ea54d60f7e4-image.png)

## 빅 오 표기법 
O(N)
- 선형 시간. N 단계가 걸림. 

O(log N)
- 로그 시간. 데이터가 두 배로 증가할 때 한 단계씩 늘어남. 


O(1)
- 상수 시간. 차수 1. 데이터 크기에 상관 없이 필요한 단계 수가 일정함. 

## 빅 오로 코드 속도 올리기
정렬되지 않은 배열을 오름차순으로 정렬하는 방법.

### 🎈 버블 정렬: 
배열 내에 연속된 두 항목을 가리켜 비교해서 우측에 더 큰 값이 위치하도록 교환(swap)을 하고 포인터를 우측으로 한 셀씩 이동한다. 이렇게 하면 첫번째 항목은 정렬된다. 그다음 정렬되지 않은 다음 항목 (두번째 항목)에서 시작해서 더 이상 교환이 없을 때까지 정렬되지 않은 위치로 돌아와서 반복한다. 

패스스루 : 위 단계를 한번 실행하는 것. 
```py
# 정렬되지 않은 배열 길이
unsorted_until_index = len(list) -1
# 좌측 값이 더 크면 서로 위치 교환
if list[i] > list[i+1]:
	list[i], list[i+1] = list[i+1], list[i]
```


## 빅 오를 사용하거나 사용하지 않는 코드 최적화
### 🎳 선택 정렬: 
첫 번째 셀을 임의로 가장 작은 숫자로 정한(선택) 후 좌측에서 우측 방향으로 배열의 각 셀을 첫 번째 셀과 비교하면서 최소값을 찾는다. 더 작은 값을 찾으면 해당 값의 위치로 대체한다. 마지막 셀 값까지 비교가 완성되면 가장 작은 값의 인덱스를 보관하고 있게 된다. 해당 인덱스의 값을 패스스루의 시발점에 있는 인덱스의 값과 교환한다. 다음 최소값은 정렬되지 않은 나머지 값 (두번째 인덱스)에서 시작하며 동일한 패스스로 과정을 실행한다.
```js
var lowestNumberIndex = i; // i=0 at first

// 최소값을 찾기 위해서 배열 내에 연속된 두 항목을 가리켜 비교. 최소값이 있는 인덱스 저장. 
if(array[i+1) < array[lowestNumberIndex[){
  lowestNumberIndex = j;
}

// 배열에서 찾은 최소값과 정렬되지 않은 첫 번째 인덱스에 있는 값 교환 
if(lowestNumberIndex != i){
  var temp = array[i];
  array[i] = array[lowestNumberIndex];
  array[lowestNumberIndex] = temp;
}


```
![](/images/d3e56947-4638-4064-a36a-6d7fe4aa1071-image.png)

## 긍정적인 시나리오 최적화
### 🎨 삽입 정렬:
인덱스 1의 값을 임시 변수에 저장한다. 해당 값의 좌측에 있는 값이 임시 변수에 저장된 값보다 크면 좌측의 있던 값을 우측으로 시프트한다. 그럼 임시 변수가 있던 값의 공백은 왼쪽으로 옮겨진다. 옮겨지지 않은 다음 좌측 값과 임시 변수 값하고 비교해서 좌측 값이 더 클 경우에 동일한 방법으로 우측 시프트를 한다. 

정렬된 인덱스 1의 값을 제외하고 다음 값에서 시작해서 인덱스를 1씩 올라가면서 완전히 정렬되기 까지 패스스루를 반복한다. 
```py
# 인덱스 1의 값을 임시 변수에 저장
position = index # 1
temp_value = array[index]

# 임시 변수에 저장된 값과 좌측 셀에 있는 값 비교해서 좌측 값이 더 크면 교환 (swap). 
#다음 좌측값도 같은 임시변수에 있는 값과 비교
while position > 0 and array[position-1] > temp_value:
	array[position] = array[position-1]
    position = position -1

array[position] = temp_value

```

## 해시 테이블로 빠른 룩업
- 해시 테이블 : 키와 값 쌍으로 이뤄진 값들의 리스트.
- 해싱 : 문자를 가져와 숫자로 변환하는 과정
- 해시 함수 : 글자를 특정 숫자로 변화하는데 사용한 코드. 동일한 문자열로 항상 동일한 숫자로 변환해야 유효함.
- 충돌(collision) : 이미 채워진 셀에 데이터를 추가하는 것
- 분리 연결법 : 충돌이 발생했을 때 셀에 값을 넣는 대신 배열로의 참조를 넣는 방법. 

### 해시 테이블 효율성 결정 요인
- 얼마나 많은 데이터 저장 가능
- 얼마나 많은 셀 사용 가능
- 어떤 해시 함수를 사용

## 스택과 큐로 간결한 코드 생성

## 재귀를 사용한 재귀적 반복

## 속도를 높이는 재귀 알고리즘

## 노드 기반 자료 구조

## 이진 트리 속도 향상

## 그래프로 뭐든지 연결

## 공간 제약 다루기



### 출처
누구나 자료구조와 알고리즘 - 제이 웬그로우
https://andrew0409.tistory.com/143 [코인하는 프로그래머]
https://program-developer.tistory.com/106